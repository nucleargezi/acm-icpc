use std::collections::HashMap;

pub use __cargo_equip::prelude::*;

use rlib_io::*;
#[allow(unused_imports)]
use rlib_show::*;

fn solve(cin: &mut Reader, cout: &mut Writer, _test: usize) {
    make_output_macro!(cin, cout);

    let n: i32 = cin.read();
    let mut k: i32 = cin.read();
    let mut mp = HashMap::new();
    for i in 0..n {
        let x: i32 = cin.read();
        *mp.entry(x).or_insert(0) += 1;
    }
    let mut b: Vec<(i32, i32)> = mp.into_iter().collect();
    b.sort_by_key(|&(_, y)| y);

    let mut ans: i32 = b.len() as i32;
    b.pop();
    for (_, y) in b {
        if y > k {
            break;
        } else {
            ans -= 1;
            k -= y;
        }
    }
    outln!(ans);
}

fn main() {
    make_io!(cin, cout);
    let tests: usize = cin.read();
    // let tests: usize = 1;
    for test in 1..=tests {
        solve(&mut cin, &mut cout, test);
    }
}

#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod rlib_io {use crate::__cargo_equip::preludes::rlib_io::*;pub use crate::__cargo_equip::macros::rlib_io::*;pub mod output_macro{use crate::__cargo_equip::preludes::rlib_io::*;#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_io_out_impl{($writer:ident,$x:expr)=>{$writer.write(&$x);};($writer:ident,$x:expr,$($xx:tt)*)=>{$writer.write(&$x);$writer.write_char(' ');rlib_io::out_impl!($writer,$($xx)*);};}macro_rules!out_impl{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_io_out_impl!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_io_make_output_macro_{($reader:ident,$writer:ident)=>{#[allow(unused_variables)]let mut$reader=$reader;#[allow(unused_variables)]let mut$writer=$writer;make_output_macro_!($reader,$writer,$);};($reader:ident,$writer:ident,$dol:tt)=>{#[allow(unused_macros)]macro_rules!out{($dol($dol x:tt)*)=>{rlib_io::out_impl!($writer,$dol($dol x)*);};}#[allow(unused_macros)]macro_rules!outln{()=>{$writer.write_char('\n');};($dol($dol x:tt)*)=>{rlib_io::out_impl!($writer,$dol($dol x)*);$writer.write_char('\n');};}}}macro_rules!make_output_macro_{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_io_make_output_macro_!{$($tt)*})}pub use crate::__cargo_equip::crates::rlib_io::make_output_macro_ as make_output_macro;}pub mod reader{use crate::__cargo_equip::preludes::rlib_io::*;use std::io::Read;pub struct Reader<'a>{buf:[u8;Reader::BUF_SIZE],begin:usize,end:usize,stdin:Box<dyn Read+'a>,eof:bool,}impl<'a>Reader<'a>{const BUF_SIZE:usize=1<<16;pub fn new(stdin:Box<dyn Read+'a>)->Self{Self{buf:[0;Reader::BUF_SIZE],begin:0,end:0,stdin,eof:false,}}pub fn read<T:Readable>(&mut self)->T{T::read(self)}pub fn read_line(&mut self)->Option<String>{let mut result=String::new();let mut read_something=false;while{if self.begin==self.end{self.refill();}!self.eof}{let c=self.peek()as char;result.push(c);self.begin+=1;read_something=true;if c=='\r'&&self.peek()==b'\n'{result.pop().unwrap();self.begin+=1;break;}else if c=='\n'{result.pop().unwrap();break;}}if read_something{Some(result)}else{None}}pub fn read_lines(&mut self)->Vec<String>{(0..).map_while(|_|self.read_line()).collect()}pub fn read_vec<T:Readable>(&mut self,n:usize)->Vec<T>{let mut result=Vec::<T>::with_capacity(n);for _ in 0..n{result.push(self.read());}result}pub fn is_eof(&mut self)->bool{self.skip_whitespace();self.eof}fn refill(&mut self){if self.eof{return;}if self.begin!=0{self.buf.copy_within(self.begin..self.end,0);self.end-=self.begin;self.begin=0;}let bytes=self.stdin.read(&mut self.buf[self.end..]).unwrap();if bytes==0{self.eof=true;}self.end+=bytes;}fn skip_whitespace(&mut self){while{if self.begin==self.end{self.refill();}!self.eof&&self.peek().is_ascii_whitespace()}{self.begin+=1;if self.begin==self.end{self.refill();}}}fn peek(&mut self)->u8{if self.begin==self.end{self.refill();}self.buf[self.begin]}}pub trait Readable{fn read(reader:&mut Reader)->Self;}impl Readable for String{fn read(reader:&mut Reader)->Self{reader.skip_whitespace();let mut result=String::new();let mut read_something=false;while{if reader.begin==reader.end{reader.refill();}!reader.eof&&!reader.peek().is_ascii_whitespace()}{result.push(reader.peek()as char);reader.begin+=1;read_something=true;}debug_assert!(read_something);result}}impl Readable for char{fn read(reader:&mut Reader)->Self{reader.skip_whitespace();debug_assert!(!reader.eof);let result=reader.peek()as char;reader.begin+=1;result}}macro_rules!read_signed{($t:ty)=>{impl Readable for$t{fn read(reader:&mut Reader)->Self{reader.skip_whitespace();let mut result:$t=0;let mut read_something=false;if reader.peek()==b'-'{reader.begin+=1;while{if reader.begin==reader.end{reader.refill();}!reader.eof&&!reader.peek().is_ascii_whitespace()}{debug_assert!(reader.buf[reader.begin].is_ascii_digit());result=result*10-(reader.buf[reader.begin]-b'0')as$t;reader.begin+=1;read_something=true;}}else{while{if reader.begin==reader.end{reader.refill();}!reader.eof&&!reader.peek().is_ascii_whitespace()}{debug_assert!(reader.buf[reader.begin].is_ascii_digit());result=result*10+(reader.buf[reader.begin]-b'0')as$t;reader.begin+=1;read_something=true;}}debug_assert!(read_something);result}}};}macro_rules!read_unsigned{($t:ty)=>{impl Readable for$t{fn read(reader:&mut Reader)->Self{reader.skip_whitespace();let mut result:$t=0;let mut read_something=false;while{if reader.begin==reader.end{reader.refill();}!reader.eof&&!reader.peek().is_ascii_whitespace()}{debug_assert!(reader.buf[reader.begin].is_ascii_digit());result=result*10+(reader.buf[reader.begin]-b'0')as$t;reader.begin+=1;read_something=true;}debug_assert!(read_something);result}}};}read_signed!(i8);read_signed!(i16);read_signed!(i32);read_signed!(i64);read_signed!(i128);read_signed!(isize);read_unsigned!(u8);read_unsigned!(u16);read_unsigned!(u32);read_unsigned!(u64);read_unsigned!(u128);read_unsigned!(usize);macro_rules!read_tuple{($($t:ident),*)=>{impl<$($t:Readable,)*>Readable for($($t,)*){fn read(reader:&mut Reader)->Self{($($t::read(reader)),*)}}}}read_tuple!(A,B);read_tuple!(A,B,C);read_tuple!(A,B,C,D);read_tuple!(A,B,C,D,E);read_tuple!(A,B,C,D,E,F);read_tuple!(A,B,C,D,E,F,G);read_tuple!(A,B,C,D,E,F,G,H);}pub mod writer{use crate::__cargo_equip::preludes::rlib_io::*;use std::io::Write;use rlib_num_traits::FixedSizeInteger;pub struct Writer<'a>{buf:[u8;Writer::BUF_SIZE],end:usize,stdout:Box<dyn Write+'a>,}impl<'a>Writer<'a>{const BUF_SIZE:usize=1<<16;pub fn new(stdout:Box<dyn Write+'a>)->Self{Self{buf:[0;Writer::BUF_SIZE],end:0,stdout,}}pub fn write<T:Writable>(&mut self,t:&T){t.write(self);#[cfg(debug_assertions)]self.flush();}pub fn write_char(&mut self,c:char){self.write_bytes(&[c as u8]);#[cfg(debug_assertions)]self.flush();}pub fn flush(&mut self){if self.end==0{return;}self.stdout.write_all(&self.buf[..self.end]).unwrap();self.end=0;}fn reserve(&mut self,size:usize){if self.end+size>self.buf.len(){self.flush();}}fn write_bytes(&mut self,buf:&[u8]){self.reserve(buf.len());self.buf[self.end..self.end+buf.len()].copy_from_slice(buf);self.end+=buf.len();}}impl Drop for Writer<'_>{fn drop(&mut self){self.flush();}}pub trait Writable{fn write(&self,writer:&mut Writer);}impl Writable for&str{fn write(&self,writer:&mut Writer){for chunk in self.as_bytes().chunks(Writer::BUF_SIZE){writer.write_bytes(chunk);}}}impl Writable for String{fn write(&self,writer:&mut Writer){for chunk in self.as_bytes().chunks(Writer::BUF_SIZE){writer.write_bytes(chunk);}}}impl<T:Writable>Writable for Vec<T>{fn write(&self,writer:&mut Writer){for(i,value)in self.iter().enumerate(){if i!=0{writer.write_char(' ');}writer.write(value);}}}macro_rules!write_unsigned{($t:ty)=>{impl Writable for$t{fn write(&self,writer:&mut Writer){if self==&0{writer.write_char('0');return;}let mut buf=[0;<$t as FixedSizeInteger>::BASE_10_LEN];let mut index=buf.len();let mut value=*self;while value!=0{index-=1;buf[index]=(value%10)as u8+b'0';value/=10;}writer.write_bytes(&buf[index..]);}}};}macro_rules!write_signed{($t:ty)=>{impl Writable for$t{fn write(&self,writer:&mut Writer){if self<&0{writer.write_char('-');}writer.write(&self.unsigned_abs());}}};}write_signed!(i8);write_signed!(i16);write_signed!(i32);write_signed!(i64);write_signed!(i128);write_signed!(isize);write_unsigned!(u8);write_unsigned!(u16);write_unsigned!(u32);write_unsigned!(u64);write_unsigned!(u128);write_unsigned!(usize);macro_rules!write_tuple{($t1:ident,$($t:ident),*)=>{impl<$t1:Writable,$($t:Writable,)*>Writable for($t1,$($t,)*){fn write(&self,writer:&mut Writer){#[allow(non_snake_case)]let($t1,$($t,)*)=self;writer.write($t1);$(writer.write_char(' ');writer.write($t);)*}}}}write_tuple!(A,B);write_tuple!(A,B,C);write_tuple!(A,B,C,D);write_tuple!(A,B,C,D,E);write_tuple!(A,B,C,D,E,F);write_tuple!(A,B,C,D,E,F,G);write_tuple!(A,B,C,D,E,F,G,H);}pub use output_macro::make_output_macro;pub use reader::{Readable,Reader};pub use writer::{Writable,Writer};#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_io_make_io{($reader:ident,$writer:ident)=>{let _stdin_=std::io::stdin();#[allow(unused_variables)]let mut$reader=rlib_io::reader::Reader::new(Box::new(_stdin_.lock()));let _stdout_=std::io::stdout();#[allow(unused_variables)]let mut$writer=rlib_io::writer::Writer::new(Box::new(_stdout_.lock()));rlib_io::output_macro::make_output_macro!($reader,$writer);};}macro_rules!make_io{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_io_make_io!{$($tt)*})}}
        pub mod rlib_num_traits {use std::cmp::*;use std::fmt::{Debug,Display};use std::ops::*;pub trait ZeroOne{const ZERO:Self;const ONE:Self;}pub trait MinMax{const MIN:Self;const MAX:Self;}pub trait Integer:for<'a>Add<&'a Self,Output=Self>+for<'a>AddAssign<&'a Self>+for<'a>Sub<&'a Self,Output=Self>+for<'a>SubAssign<&'a Self>+for<'a>Div<&'a Self,Output=Self>+for<'a>DivAssign<&'a Self>+for<'a>Rem<&'a Self,Output=Self>+for<'a>RemAssign<&'a Self>+for<'a>Mul<&'a Self,Output=Self>+for<'a>MulAssign<&'a Self>+ZeroOne+MinMax+PartialEq+Eq+PartialOrd+Ord+Clone+Sized+Default+Display+Debug{fn abs(&self)->Self;fn into_abs(self)->Self;}pub trait FixedSizeInteger:Integer+Add<Self,Output=Self>+AddAssign<Self>+Sub<Self,Output=Self>+SubAssign<Self>+Div<Self,Output=Self>+DivAssign<Self>+Rem<Self,Output=Self>+RemAssign<Self>+Mul<Self,Output=Self>+MulAssign<Self>+Copy{type Unsigned:Integer;type Signed:Integer;const BASE_10_LEN:usize;fn unsigned_abs(self)->Self::Unsigned;}pub trait Float:Add<Output=Self>+AddAssign+Sub<Output=Self>+SubAssign+Div<Output=Self>+DivAssign+Mul<Output=Self>+MulAssign+Neg<Output=Self>+ZeroOne+PartialEq+PartialOrd+Clone+Copy+Default+Sized+Display+Debug{const PI:Self;fn sin(&self)->Self;fn cos(&self)->Self;fn sqrt(&self)->Self;fn abs(&self)->Self;fn round(&self)->Self;fn from_usize(x:usize)->Self;fn from_i32(x:i32)->Self;fn to_i64(&self)->i64;}macro_rules!integer_common{($it:ty,$ut:ty,$len:expr)=>{type Unsigned=$ut;type Signed=$it;const BASE_10_LEN:usize=$len;};}macro_rules!base_10_len{($ut:ty)=>{{let mut value=<$ut>::MAX;let mut ans:usize=0;while value!=0{value/=10;ans+=1;}ans}};}macro_rules!fixed_size_integer{($it:ty,$ut:ty,$len:expr)=>{impl Integer for$it{fn abs(&self)->Self{<$it>::abs(*self)}fn into_abs(self)->Self{<$it>::abs(self)}}impl FixedSizeInteger for$it{integer_common!($it,$ut,$len);fn unsigned_abs(self)->Self::Unsigned{Self::unsigned_abs(self)}}impl Integer for$ut{fn abs(&self)->Self{*self}fn into_abs(self)->Self{self}}impl FixedSizeInteger for$ut{integer_common!($it,$ut,$len);fn unsigned_abs(self)->Self::Unsigned{self}}};($it:ty,$ut:ty)=>{fixed_size_integer!($it,$ut,base_10_len!($ut));};}macro_rules!impl_zomm{($($t:ty),*)=>{$(impl ZeroOne for$t{const ZERO:$t=0 as$t;const ONE:$t=1 as$t;}impl MinMax for$t{const MIN:$t=<$t>::MIN;const MAX:$t=<$t>::MAX;})*};}fixed_size_integer!(i8,u8);fixed_size_integer!(i16,u16);fixed_size_integer!(i32,u32);fixed_size_integer!(i64,u64);fixed_size_integer!(i128,u128);fixed_size_integer!(isize,usize);impl_zomm!(i8,u8,i16,u16,i32,u32,i64,u64,i128,u128,isize,usize);impl_zomm!(f32,f64);macro_rules!impl_float{($t:ty,$pi:expr)=>{impl Float for$t{const PI:Self=$pi;fn sin(&self)->Self{<$t>::sin(*self)}fn cos(&self)->Self{<$t>::cos(*self)}fn sqrt(&self)->Self{<$t>::sqrt(*self)}fn abs(&self)->Self{<$t>::abs(*self)}fn round(&self)->Self{<$t>::round(*self)}fn from_usize(x:usize)->Self{x as$t}fn from_i32(x:i32)->Self{x as$t}fn to_i64(&self)->i64{self.round()as i64}}};}impl_float!(f32,std::f32::consts::PI);impl_float!(f64,std::f64::consts::PI);}
        pub mod rlib_show {use crate::__cargo_equip::preludes::rlib_show::*;pub use crate::__cargo_equip::macros::rlib_show::*;mod impls{use crate::__cargo_equip::preludes::rlib_show::*;use std::collections::{BTreeMap,BTreeSet,HashMap,HashSet};use rlib_num_traits::FixedSizeInteger as _;use crate::__cargo_equip::crates::rlib_show::traits::{Show,ShowPretty,ShowSettings};macro_rules!show_int{($tp:ty,$inf_tp:ident,$inf:ident)=>{impl Show for$tp{#[allow(unused_comparisons)]fn show(&self,settings:&ShowSettings)->String{if(self.unsigned_abs()as$inf_tp)<settings.$inf{self.to_string()}else if*self<0{"-inf".into()}else{"inf".into()}}}};}show_int!(i8,u32,inf_32);show_int!(u8,u32,inf_32);show_int!(i16,u32,inf_32);show_int!(u16,u32,inf_32);show_int!(i32,u32,inf_32);show_int!(u32,u32,inf_32);show_int!(i64,u64,inf_64);show_int!(u64,u64,inf_64);show_int!(isize,u64,inf_64);show_int!(usize,u64,inf_64);show_int!(i128,u128,inf_128);show_int!(u128,u128,inf_128);impl Show for f32{fn show(&self,settings:&ShowSettings)->String{format!("{:.precision$}",self,precision=settings.float_precision)}}impl Show for f64{fn show(&self,settings:&ShowSettings)->String{format!("{:.precision$}",self,precision=settings.float_precision)}}impl Show for&str{fn show(&self,_settings:&ShowSettings)->String{format!("\"{}\"",self)}}impl Show for str{fn show(&self,settings:&ShowSettings)->String{(&self).show(settings)}}impl Show for String{fn show(&self,settings:&ShowSettings)->String{self.as_str().show(settings)}}impl Show for char{fn show(&self,_settings:&ShowSettings)->String{format!("'{}'",self)}}impl Show for bool{fn show(&self,_settings:&ShowSettings)->String{if*self{"true"}else{"false"}.to_string()}}impl<T:Show>Show for[T]{fn show(&self,settings:&ShowSettings)->String{let mut res="[".to_string();let mut first=true;for item in self.iter(){if!first{res.push_str(", ");}res.push_str(&format!("{: >width$}",item.show(settings),width=settings.item_width));first=false;}res.push(']');res}}impl<T:Show,const N:usize>Show for[T;N]{fn show(&self,settings:&ShowSettings)->String{self.as_slice().show(settings)}}impl<T:Show>Show for Vec<T>{fn show(&self,settings:&ShowSettings)->String{(self[..]).show(settings)}}impl<T:Show>ShowPretty for[Vec<T>]{fn show_pretty(&self,settings:&ShowSettings)->String{let mut widths:Vec<usize> =Vec::new();let mut mat=Vec::new();for row in self.iter(){mat.push(row.iter().map(|x|x.show(settings)).collect::<Vec<_>>());for(i,x)in mat.last().unwrap().iter().enumerate(){if i>=widths.len(){widths.push(settings.item_width);}widths[i]=widths[i].max(x.len());}}let mut lines=Vec::new();for(i,row)in mat.iter().enumerate(){let pref=if i==0{'['}else{' '};let suf=if i+1==mat.len(){']'}else{','};let row=row.iter().enumerate().map(|(j,x)|format!("{:>width$}",x,width=widths[j])).collect::<Vec<_>>().join(", ");lines.push(format!("{}[{}]{}",pref,row,suf));}lines.join("\n")}}macro_rules!show_map{($tp:ty)=>{impl<K:Show,V:Show>Show for$tp{fn show(&self,settings:&ShowSettings)->String{let mut res="{".to_string();let mut first=true;for(k,v)in self.iter(){if!first{res.push_str(", ");}res.push_str(&format!("({: >width$}, {: >width$})",k.show(settings),v.show(settings),width=settings.item_width));first=false;}res.push('}');res}}impl<K:Show,V:Show>ShowPretty for$tp{fn show_pretty(&self,settings:&ShowSettings)->String{let mut widths=[settings.item_width,settings.item_width];let mut items=Vec::new();for(k,v)in self.iter(){let item=[k.show(settings),v.show(settings)];for i in 0..2{widths[i]=widths[i].max(item[i].len());}items.push(item);}let mut lines=Vec::new();for(i,row)in items.iter().enumerate(){let pref=if i==0{'{'}else{' '};let suf=if i+1==items.len(){'}'}else{','};let row=format!("{:<k_width$}: {:<v_width$}",row[0],row[1],k_width=widths[0],v_width=widths[1]);lines.push(format!("{}{}{}",pref,row,suf));}lines.join("\n")}}};}show_map!(BTreeMap<K,V>);show_map!(HashMap<K,V>);macro_rules!show_set{($tp:ty)=>{impl<T:Show>Show for$tp{fn show(&self,settings:&ShowSettings)->String{let mut res="{".to_string();let mut first=true;for item in self.iter(){if!first{res.push_str(", ");}res.push_str(&format!("{: >width$}",item.show(settings),width=settings.item_width));first=false;}res.push('}');res}}};}show_set!(BTreeSet<T>);show_set!(HashSet<T>);macro_rules!show_tuple{($t:ident,)=>{};($t1:ident,$($t:ident,)*)=>{impl<$t1:Show,$($t:Show,)*>Show for($t1,$($t,)*){fn show(&self,settings:&ShowSettings)->String{let mut res="(".to_string();#[allow(non_snake_case)]let($t1,$($t,)*)=self;res.push_str(&$t1.show(settings));$(res.push_str(", ");res.push_str(&$t.show(settings));)*res.push(')');res}}show_tuple!($($t,)*);}}show_tuple!(A,B,C,D,E,F,G,H,I,J,K,L,);}mod traits{use crate::__cargo_equip::preludes::rlib_show::*;pub struct ShowSettings{pub inf_32:u32,pub inf_64:u64,pub inf_128:u128,pub float_precision:usize,pub item_width:usize,pub colors:bool,pub mint_max:i64,pub mint_rational:bool,}impl ShowSettings{pub const fn new()->Self{Self{inf_32:10u32.pow(9),inf_64:10u64.pow(18),inf_128:10u128.pow(36),float_precision:9,item_width:0,colors:true,mint_max:100,mint_rational:true,}}}impl Default for ShowSettings{fn default()->Self{Self::new()}}pub static mut SHOW_SETTINGS:ShowSettings=ShowSettings::new();pub trait Show{fn show(&self,settings:&ShowSettings)->String;}pub trait ShowPretty:Show{fn show_pretty(&self,settings:&ShowSettings)->String{self.show(settings)}}}pub use traits::{Show,ShowPretty,ShowSettings,SHOW_SETTINGS};#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_is_show{()=>{std::option_env!("HOUSE").is_some()};}macro_rules!is_show{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_is_show!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_show{($($arg:expr),*)=>{if is_show!(){#[allow(static_mut_refs)]let settings=unsafe{&rlib_show::SHOW_SETTINGS};let mut line=format!("[{:>3}] ",line!());if settings.colors{line=format!("\x1b[34m{}\x1b[0m",line);}eprint!("{}",line);$(eprint!(" [{}: {}]",stringify!($arg),$arg.show(settings));)*eprintln!();}};}macro_rules!show{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_show!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_show_pretty{($arg:expr)=>{if is_show!(){#[allow(static_mut_refs)]let settings=unsafe{&rlib_show::SHOW_SETTINGS};let mut line=format!("[{:>3}] ",line!());if settings.colors{line=format!("\x1b[34m{}\x1b[0m",line);}eprint!("{}",line);let out=$arg.show_pretty(settings);let var=stringify!($arg);let ident=line.len()+var.len()+5;let lines=out.lines().collect::<Vec<_>>();for(i,line)in lines.iter().enumerate(){if i==0{eprint!(" [{}: {}",var,line);}else{eprint!("{}{}"," ".repeat(ident),line);}if i+1==lines.len(){eprint!("]");}eprintln!();}}};}macro_rules!show_pretty{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_show_pretty!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_show_cfg{()=>{if is_show!(){unsafe{rlib_show::SHOW_SETTINGS=ShowSettings::new();}}};($opt:ident,$value:expr)=>{if is_show!(){let value=$value;unsafe{rlib_show::SHOW_SETTINGS.$opt=value;}}};}macro_rules!show_cfg{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_show_cfg!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_show_struct{($s:ty,$($field:ident),*)=>{impl rlib_show::Show for$s{fn show(&self,settings:&rlib_show::ShowSettings)->String{let mut fields=Vec::new();$(fields.push(format!("{}: {}",stringify!($field),self.$field.show(settings)));)*format!("{{{}}}",fields.join(", "))}}};}macro_rules!show_struct{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_show_struct!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_rlib_show_show_struct_debug{($($s:ty),*)=>{$(impl rlib_show::Show for$s{fn show(&self,settings:&rlib_show::ShowSettings)->String{format!("{:?}",self)}})*};}macro_rules!show_struct_debug{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_rlib_show_show_struct_debug!{$($tt)*})}}
    }

    pub(crate) mod macros {
        pub mod rlib_io {pub use crate::{__cargo_equip_macro_def_rlib_io_make_io as make_io,__cargo_equip_macro_def_rlib_io_make_output_macro_ as make_output_macro_,__cargo_equip_macro_def_rlib_io_out_impl as out_impl};}
        pub mod rlib_num_traits {}
        pub mod rlib_show {pub use crate::{__cargo_equip_macro_def_rlib_show_is_show as is_show,__cargo_equip_macro_def_rlib_show_show as show,__cargo_equip_macro_def_rlib_show_show_cfg as show_cfg,__cargo_equip_macro_def_rlib_show_show_pretty as show_pretty,__cargo_equip_macro_def_rlib_show_show_struct as show_struct,__cargo_equip_macro_def_rlib_show_show_struct_debug as show_struct_debug};}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::crates::*;}

    mod preludes {
        pub mod rlib_io {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::rlib_num_traits;}
        pub mod rlib_num_traits {}
        pub mod rlib_show {pub(in crate::__cargo_equip)use crate::__cargo_equip::crates::rlib_num_traits;}
    }
}
